use num_bigint_dig::BigInt;
use circom_ast::*;
use circom_ast::ast_shortcuts::{self, Symbol};
use crate::errors::Error;
use lalrpop_util::ParseError;

grammar<'err>(file_id: usize, errors:&'err mut Vec<Error>);

CommaSepList<T>:Vec<T> = {
    <mut e:(<T> ",")*> <t:T> => {
        e.push(t);
        e
    },
};

Semicolon:() = {
    ";" => (),
    // try your best buddy
    <!> => errors.push(Error::MissingSemicolon)
}

// ====================================================================
// Body
// ====================================================================

// Pragmas are included at the start of the file,
// their structure is the following: 
// 'pragma circom "version of the compiler"' to indicate the version
// or
// 'pragma custom_templates' to indicate that we are allowing the definition of custom gates.

ParsePragma:Pragma = {
    // version
    "pragma" "circom" <Version> Semicolon => Pragma::Version(<>),
    "pragma" "circom" <!> Semicolon => match <>.error {
            ParseError::UnrecognizedToken { ref token, .. } => {
                errors.push(Error::UnrecognizedVersion{location: token.0..token.2, file_id});
                Pragma::Unrecognized
            } 
            _ => unreachable!(),
        },
    // custom templates
    "pragma" "custom_templates" Semicolon => Pragma::CustomGates,
    // unrecognized
    "pragma" <!> Semicolon => match <>.error {
            ParseError::UnrecognizedToken { ref token, .. } => {
                errors.push(Error::UnrecognizedPragma{location: token.0..token.2, file_id});
                Pragma::Unrecognized
            } 
            _ => unreachable!(),
        },
};

// Includes are added at the start of the file.
// Their structure is the following:#include "path to the file"
ParseInclude:String = {
    "include" <STRING> Semicolon => <>,
    "include" <!> Semicolon => {
        match <>.error {
            ParseError::UnrecognizedToken { ref token, .. } => {
                errors.push(Error::UnrecognizedInclude{location: token.0..token.2, file_id});
            } 
            _ => unreachable!(),
        }
        "".to_owned()
    },
};

// Parsing a program requires:
// Parsing the version pragma, if there is one
// Parsing the custom gates pragma, if there is one
// Parsing "includes" instructions, if there is anyone
// Parsing function and template definitions
// Parsing the declaration of the main component
pub ParseAst:AST = {
    <s:@L> <pragmas:ParsePragma*> <includes:ParseInclude*> <definitions:ParseDefinition*> <main:ParseMainComponent?> <e:@R>
    => AST::new(Meta::new(s,e), pragmas, includes, definitions, main),
};

// ====================================================================
// Definitions
// ====================================================================

// The private list of the main component stands for the
// list of private input signals
ParsePublicList:Vec<String> = {
    "{" "public" "[" <CommaSepList<ID>> "]" "}" => <>,
};

pub ParseMainComponent:MainComponent = {
    <s:@L> "component" "main" <public_list:ParsePublicList?> "=" <init:Expression> Semicolon <e:@L>
    => match public_list {
        None        => MainComponent::new(vec![], init),
        Some(list)  => MainComponent::new(list, init)
    },
};

pub ParseDefinition:Definition = {
    <s:@L> "function" <name:ID> "(" <args:@L> <arg_names:CommaSepList<ID>?> <arge:@R> ")" <body:Block> <e:@R>
    => match arg_names {
        None    => Definition::build_function(Meta::new(s,e),name,Vec::new(),args..arge,body),
        Some(a) => Definition::build_function(Meta::new(s,e),name,a,args..arge,body),
    },
    <s:@L> "template" <custom_gate:"custom"?> <parallel:"parallel"?> <name:ID> "(" <args:@L> <arg_names:CommaSepList<ID>?> <arge:@R> ")" <body:Block> <e:@R>
    => match arg_names {
        None    => Definition::build_template(Meta::new(s,e), name, Vec::new(), args..arge, body, parallel.is_some(), custom_gate.is_some()),
        Some(a) => Definition::build_template(Meta::new(s,e), name, a, args..arge, body, parallel.is_some(), custom_gate.is_some()),
    },
};

// ====================================================================
// VariableDefinitions
// ====================================================================

ParseElementType:SignalElementType = {
    "FieldElement"  => SignalElementType::FieldElement,
    "Binary"        => SignalElementType::Binary,
};

ParseSignalType:SignalType = {
    "input"     => SignalType::Input,
    "output"    => SignalType::Output
};

SignalHeader:VariableType = {
    "signal" <element_type:(":" <ParseElementType>)?> <signal_type:ParseSignalType?>
    => {
        let e = element_type.unwrap_or(SignalElementType::FieldElement);
        let s = signal_type.unwrap_or(SignalType::Intermediate);
        VariableType::Signal(s,e)
    }
};

// ====================================================================
// Statements
// ====================================================================

// A Initialization is either just the name of a variable or
// the name followed by a expression that initializes the variable.

SimpleSymbol:Symbol = {
    <name:ID> <is_array:ParseArrayAcc*>
    => Symbol { name, is_array, init:None },
}

ComplexSymbol:Symbol = {
    <name:ID> <is_array:ParseArrayAcc*> "=" <rhe:Expression>
    => Symbol { name, is_array, init:Some(rhe) },
};

SignalConstraintSymbol:Symbol = {
    <name:ID> <is_array:ParseArrayAcc*> "<==" <rhe:Expression>
    => Symbol { name, is_array, init:Some(rhe) },
};

SignalSimpleSymbol:Symbol = {
    <name:ID> <is_array:ParseArrayAcc*> "<--" <rhe:Expression>
    => Symbol { name, is_array, init:Some(rhe) },
};

SomeSymbol:Symbol = {
    ComplexSymbol,
    SimpleSymbol,
}

SignalSymbol:Symbol = {
    SimpleSymbol,
    SignalConstraintSymbol,
}

// A declaration is the definition of a type followed by the initialization
ParseDeclaration:Statement = {
    <s:@L> "var" <symbols:CommaSepList<SomeSymbol>> <e:@R> => {
            let meta = Meta::new(s,e);
            let xtype = VariableType::Var;
            ast_shortcuts::split_declaration_into_single_nodes(meta,xtype,symbols,AssignOp::AssignVar)
    },
    <s:@L> "component" <symbols:CommaSepList<SomeSymbol>> <e:@R> => {
            let meta = Meta::new(s,e);
            let xtype = VariableType::Component;
            ast_shortcuts::split_declaration_into_single_nodes(meta, xtype, symbols, AssignOp::AssignVar)
    },
    <s:@L><xtype:SignalHeader> <symbols:CommaSepList<SignalSymbol>> <e:@R>
    => {
            let meta = Meta::new(s,e);
            ast_shortcuts::split_declaration_into_single_nodes(meta, xtype, symbols, AssignOp::AssignConstraintSignal)
    },
    <s:@L><xtype:SignalHeader> <symbols:CommaSepList<SignalSimpleSymbol>> <e:@R>
    => {
            let meta = Meta::new(s,e);
            ast_shortcuts::split_declaration_into_single_nodes(meta, xtype, symbols, AssignOp::AssignSignal)
    },
};

ParseSubstitution:Statement = {
    <s:@L> <variable:ParseVariable> <op:ParseAssignOp> <rhe:Expression> <e:@R>
    => {
        let (name, access) = variable;
        Statement::build_substitution(Meta::new(s,e),name,access,op,rhe)
       },
    <s:@L> <lhe:Expression> "-->" <variable:ParseVariable> <e:@R>
    => {
        let (name, access) = variable;
        Statement::build_substitution(Meta::new(s,e),name,access,AssignOp::AssignSignal,lhe)
       },
    <s:@L> <lhe:Expression> "==>" <variable:ParseVariable>  <e:@R>
    => {
        let (name, access) = variable;
        Statement::build_substitution(Meta::new(s,e),name,access,AssignOp::AssignConstraintSignal,lhe)
       },
    <s:@L> <variable:ParseVariable>  "\\=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::IntDiv,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "**=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::Pow,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "+=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::Add,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "-=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::Sub,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "*=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::Mul,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "/=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::Div,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "%=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::Mod,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "<<=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::ShiftL,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  ">>=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::ShiftR,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "&=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::BitAnd,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "|=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::BitOr,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "^=" <rhe:Expression> <e:@R>
    => ast_shortcuts::assign_with_op_shortcut(ExpressionInfixOpcode::BitXor,Meta::new(s,e),variable,rhe),

    <s:@L> <variable:ParseVariable>  "++" <e:@R>
    => ast_shortcuts::plusplus(Meta::new(s,e),variable),

    <s:@L> <variable:ParseVariable>  "--" <e:@R>
    => ast_shortcuts::subsub(Meta::new(s,e),variable),
};

Block:Statement = {
    <s:@L> "{" <stmts:ParseStatement*> "}" <e:@R>
    => Statement::build_block(Meta::new(s,e),stmts),
};

ParseStatement:Statement = {
    // ended by Semicolon

    <dec:ParseDeclaration> Semicolon => dec,

    <subs:ParseSubstitution> Semicolon => subs,

    <s:@L> "return" <value:Expression> Semicolon <e:@R>
    => Statement::build_return(Meta::new(s,e),value),

    <s:@L> <lhe:Expression> "===" <rhe:Expression> Semicolon <e:@R>
    => Statement::build_constraint_equality(Meta::new(s,e),lhe,rhe),

    <s:@L> "log" "(" <arg:Expression> ")" Semicolon <e:@R>
    => Statement::build_log_call(Meta::new(s,e),arg),

    <s:@L> "assert" "(" <arg:Expression> ")" Semicolon <e:@R>
    => Statement::build_assert(Meta::new(s,e),arg),

    // block like

    <s:@L> "if" "(" <cond:Expression> ")" <if_case:Block> <else_case:("else" <Block>)?> <e:@R>
    => Statement::build_conditional_block(Meta::new(s,e), cond, if_case, else_case),

    <s:@L> "for" "(" <init:ParseDeclaration> ";" <cond:Expression> ";" <step:ParseSubstitution> ")" <body:Block> <e:@R>
    => ast_shortcuts::for_into_while(Meta::new(s,e), init, cond, step, body),

    <s:@L> "for" "(" <init:ParseSubstitution> ";" <cond:Expression> ";" <step:ParseSubstitution> ")" <body:Block> <e:@R>
    => ast_shortcuts::for_into_while(Meta::new(s,e), init, cond, step, body),

    <s:@L> "while" "(" <cond:Expression> ")" <stmt:Block> <e:@R>
    => Statement::build_while_block(Meta::new(s,e),cond,stmt),

    Block
};

// ====================================================================
// Variable
// ====================================================================

ParseVarAccess:Access  = {
    <ParseArrayAcc> => Access::build_array_access(<>),
    <ParseComponentAcc> => Access::build_component_access(<>),
};

ParseArrayAcc:Expression = {
    "[" <Expression> "]" => <>,
    // empty access
    <s:@L> "[" "]" <e:@R> => {
            errors.push(Error::IllegalExpression{location: s..e, file_id});
            // doesn't matter
            Expression::build_number(Meta::new(0,0),BigInt::from(0))
    }
};

ParseComponentAcc:String = {
    "." <ID> => <>,
};

ParseVariable:(String, Vec<Access>) = {
    ID ParseVarAccess* => (<>),
};

// ====================================================================
// Expression
// ====================================================================

InfixOpTier<Op, NextTier>:Expression = {
    <s:@L> <lhe:InfixOpTier<Op, NextTier>> <op:Op> <rhe:NextTier> <e:@R> 
    => Expression::build_infix(Meta::new(s,e), lhe, op, rhe),
    NextTier
};

PrefixOpTier<Op, NextTier>:Expression = {
    <s:@L> <op:Op> <rhe:NextTier> <e:@R> 
    => Expression::build_prefix(Meta::new(s,e), op, rhe),
    NextTier
};

pub Expression:Expression = {
    Expression13,
    Expression12,
};

// ops:e ? a:i
Expression13:Expression  = {
    <s:@L> <cond:Expression12> "?" <if_true:Expression12> ":" <if_false:Expression12> <e:@R>
    => Expression::build_ternary_op(Meta::new(s,e),cond,if_true,if_false),
};

// ops:||
Expression12 = InfixOpTier<ParseBoolOr,Expression11>;

// ops:&&
Expression11 = InfixOpTier<ParseBoolAnd,Expression10>;

// ops: == != < > <= >=
Expression10 = InfixOpTier<ParseCmpOpCodes,Expression9>;

// ops:|
Expression9 = InfixOpTier<ParseBitOr,Expression8>;

// ops:^
Expression8 = InfixOpTier<ParseBitXOR,Expression7>;

// ops:&
Expression7 = InfixOpTier<ParseBitAnd,Expression6>;

// ops:<< >>
Expression6 = InfixOpTier<ParseShift,Expression5>;

// ops:+ -
Expression5 = InfixOpTier<ParseAddAndSub,Expression4>;

// ops:* / \\ %
Expression4 = InfixOpTier<ParseMulDiv,Expression3>;

// ops:**
Expression3 = InfixOpTier<ParseExp,Expression2>;

// ops:Unary - ! ~
Expression2 = PrefixOpTier<ExpressionPrefixOpcode,Expression1>;

// function call, array inline
Expression1:Expression = {
    // function call
    <s:@L> <id:ID> "(" <args:CommaSepList<Expression>?> ")" <e:@R>
    => match args {
        None => Expression::build_call(Meta::new(s,e), id, Vec::new()),
        Some(a) => Expression::build_call(Meta::new(s,e), id, a),
    },

    // array
    <s:@L> "[" <values:CommaSepList<Expression>> "]" <e:@R>
    => Expression::build_array_in_line(Meta::new(s,e),values),

    Expression0,
};

// Literals, parentheses
Expression0:Expression = {
    <s:@L> <variable:ParseVariable> <e:@L>
    => {
        let (name, access) = variable;
        Expression::build_variable(Meta::new(s,e),name,access)
    },

    <s:@L> <value:DECNUMBER> <e:@L>
    => Expression::build_number(Meta::new(s,e),value),

    <s:@L> <value:HEXNUMBER> <e:@L>
    => Expression::build_number(Meta::new(s,e),value),

    "(" <Expression12> ")",

    <!> => match <>.error {
            ParseError::UnrecognizedToken { ref token, .. } => {
                errors.push(Error::IllegalExpression{location: token.0..token.2, file_id});
                // doesn't matter
                Expression::build_number(Meta::new(0,0),BigInt::from(0))
            } 
            _ => unreachable!(),
        }
};

// ====================================================================
// Terminals
// ====================================================================

ExpressionPrefixOpcode:ExpressionPrefixOpcode = {
    "!" => ExpressionPrefixOpcode::BoolNot,
    "~" => ExpressionPrefixOpcode::Complement,
    "-" => ExpressionPrefixOpcode::Sub,
};

ParseBoolOr:ExpressionInfixOpcode = {
    "||" => ExpressionInfixOpcode::BoolOr,
};

ParseBoolAnd:ExpressionInfixOpcode = {
    "&&" => ExpressionInfixOpcode::BoolAnd,
};

ParseCmpOpCodes:ExpressionInfixOpcode = {
    "==" => ExpressionInfixOpcode::Eq,
    "!=" => ExpressionInfixOpcode::NotEq,
    "<"  => ExpressionInfixOpcode::Lesser,
    ">"  => ExpressionInfixOpcode::Greater,
    "<=" => ExpressionInfixOpcode::LesserEq,
    ">=" => ExpressionInfixOpcode::GreaterEq,
};

ParseBitOr:ExpressionInfixOpcode = {
    "|" =>  ExpressionInfixOpcode::BitOr,
};

ParseBitAnd:ExpressionInfixOpcode = {
    "&" =>  ExpressionInfixOpcode::BitAnd,
};

ParseShift:ExpressionInfixOpcode = {
    "<<" => ExpressionInfixOpcode::ShiftL,
    ">>" => ExpressionInfixOpcode::ShiftR,
};

ParseAddAndSub:ExpressionInfixOpcode = {
    "+" =>  ExpressionInfixOpcode::Add,
    "-" =>  ExpressionInfixOpcode::Sub,
};

ParseMulDiv:ExpressionInfixOpcode = {
    "*" =>  ExpressionInfixOpcode::Mul,
    "/" =>  ExpressionInfixOpcode::Div,
    "\\" => ExpressionInfixOpcode::IntDiv,
    "%" =>  ExpressionInfixOpcode::Mod,
};

ParseExp:ExpressionInfixOpcode = {
    "**" => ExpressionInfixOpcode::Pow,
};

ParseBitXOR:ExpressionInfixOpcode = {
    "^" =>  ExpressionInfixOpcode::BitXor,
};

ParseAssignOp:AssignOp = {
    "="   => AssignOp::AssignVar,
    "<--" => AssignOp::AssignSignal,
    "<==" => AssignOp::AssignConstraintSignal,
};

DECNUMBER:BigInt = {
    r"[0-9]+" => <>.parse::<BigInt>().unwrap()
};

HEXNUMBER:BigInt = {
    r"0x[0-9A-Fa-f]*" => BigInt::parse_bytes(&(<>.as_bytes()[2..]),16).unwrap()
};

ID:String = {
    r"[$_]*[a-zA-Z][a-zA-Z$_0-9]*" => <>.to_string()
};

STRING:String = {
    r#""[^"]*""# => String::from(&<>[1..<>.len()-1])
};

USIZE:usize = {
    r"[0-9]+" => <>.parse::<usize>().unwrap()
};

// Version used by pragma to describe the compiler, its syntax is Number1.Number2.Number3...
Version:Version = {
    <version:USIZE> "." <subversion:USIZE> "." <subsubversion:USIZE> => {
        Version::new(version, subversion, subsubversion)
    }
};
